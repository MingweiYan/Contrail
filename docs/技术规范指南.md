# Contrail 项目技术规范指南

## 1. 架构概述

### 1.1 整体架构

Contrail应用采用分层架构设计，包含以下四个主要层次：

```
┌─────────────────────────────────────────────────────────────┐
│                         UI Layer                            │
│  (Pages, Widgets, Navigation, Theme, UI Helpers)            │
└───────────────────┬─────────────────────────────────────────┘
                    │
┌───────────────────▼─────────────────────────────────────────┐
│                    State Layer                              │
│  (Providers, ViewModels - pure state management only)       │
└───────────────────┬─────────────────────────────────────────┘
                    │
┌───────────────────▼─────────────────────────────────────────┐
│                Domain Layer                                 │
│  (UseCases, Entities, Business Rules, Repositories)         │
└───────────────────┬─────────────────────────────────────────┘
                    │
┌───────────────────▼─────────────────────────────────────────┐
│                   Data Layer                                │
│  (Repositories Implementation, Services, Adapters)          │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 核心架构原则

所有开发必须遵循以下架构原则：

1. **依赖倒置原则**：高层模块依赖于抽象，不依赖于具体实现
2. **单一职责原则**：每个类和函数只负责一个职责
3. **接口隔离原则**：客户端不依赖它不需要的接口
4. **里氏替换原则**：子类可以替换父类使用
5. **开闭原则**：对扩展开放，对修改关闭

### 1.3 目录结构规范

```
lib/
├── core/                  # 核心功能
│   ├── di/                # 依赖注入
│   ├── routing/           # 路由配置
│   ├── services/          # 核心服务
│   └── state/             # 全局状态
├── features/              # 功能模块
│   ├── feature_name/      # 功能名称
│   │   ├── data/          # 数据层
│   │   │   ├── models/    # 数据模型
│   │   │   └── repositories/ # 仓储实现
│   │   ├── domain/        # 领域层
│   │   │   ├── entities/  # 领域实体
│   │   │   ├── repositories/ # 仓储接口
│   │   │   └── use_cases/ # 用例
│   │   └── presentation/  # 表现层
│   │       ├── pages/     # 页面
│   │       ├── providers/ # 状态管理
│   │       ├── routes/    # 路由配置
│   │       └── widgets/   # 组件
├── navigation/            # 导航相关
├── shared/                # 共享资源
│   ├── models/            # 共享模型
│   ├── services/          # 共享服务
│   ├── utils/             # 工具类
│   └── widgets/           # 共享组件
└── main.dart              # 应用入口
```

## 2. 命名规范

### 2.1 文件命名

- **类文件**：使用小驼峰命名，与类名一致
  - 示例：`habit_provider.dart`
- **接口文件**：使用`i_`前缀加小驼峰命名
  - 示例：`i_notification_service.dart`
- **实现文件**：使用实现类名加小驼峰命名
  - 示例：`notification_service_impl.dart`
- **常量文件**：使用全大写加下划线
  - 示例：`app_routes.dart`
- **工具类文件**：使用功能描述加_helper后缀
  - 示例：`theme_helper.dart`

### 2.2 类命名

- **普通类**：使用大驼峰命名
  - 示例：`HabitProvider`
- **接口类**：使用`I`前缀加大驼峰命名
  - 示例：`INotificationService`
- **实现类**：使用接口名加`Impl`后缀
  - 示例：`NotificationServiceImpl`
- **用例类**：使用功能描述加`UseCase`后缀
  - 示例：`GetHabitsUseCase`
- **异常类**：使用异常类型加`Exception`后缀
  - 示例：`DatabaseException`

### 2.3 变量和方法命名

- **变量**：使用小驼峰命名
  - 示例：`habitsList`
- **私有变量**：使用下划线前缀加小驼峰命名
  - 示例：`_privateVariable`
- **方法**：使用小驼峰命名，动词开头
  - 示例：`loadHabits()`
- **私有方法**：使用下划线前缀加小驼峰命名
  - 示例：`_initializeDatabase()`
- **常量**：使用全大写加下划线
  - 示例：`MAX_COUNT`

## 3. 代码编写规范

### 3.1 Dart 语言规范

- 遵循官方Dart语言规范
- 使用null safety
- 避免使用dynamic类型，优先使用具体类型
- 优先使用final和const
- 避免使用全局变量

### 3.2 状态管理规范

#### 3.2.1 Provider 规范

Provider类应专注于状态管理，不包含业务逻辑：

```dart
// 正确的Provider实现
class HabitProvider extends ChangeNotifier {
  final GetHabitsUseCase _getHabitsUseCase;
  final AddHabitUseCase _addHabitUseCase;
  
  List<Habit> habits = [];
  bool isLoading = false;
  String? error;
  
  HabitProvider(this._getHabitsUseCase, this._addHabitUseCase);
  
  Future<void> loadHabits() async {
    isLoading = true;
    error = null;
    notifyListeners();
    
    try {
      habits = await _getHabitsUseCase.execute();
    } catch (e) {
      error = e.toString();
    } finally {
      isLoading = false;
      notifyListeners();
    }
  }
}
```

#### 3.2.2 状态更新规范

- 在UI线程更新状态
- 使用`notifyListeners()`通知UI更新
- 避免频繁调用`notifyListeners()`
- 正确处理异步操作的状态变化

### 3.3 业务逻辑规范

业务逻辑应放在UseCase层：

```dart
class GetHabitsUseCase {
  final HabitRepository _repository;
  final ErrorHandler _errorHandler;
  
  GetHabitsUseCase(this._repository, this._errorHandler);
  
  Future<List<Habit>> execute() async {
    try {
      return await _repository.getAllHabits();
    } catch (e, stackTrace) {
      _errorHandler.handleError(e, stackTrace);
      rethrow;
    }
  }
}
```

### 3.4 数据持久化规范

- 所有数据持久化操作必须通过仓储接口
- 避免在UI层或状态层直接操作数据库
- 正确处理异步操作和错误

```dart
class HiveHabitRepository implements HabitRepository {
  final IDatabaseService _databaseService;
  final ILogger _logger;
  
  HiveHabitRepository(this._databaseService, this._logger);
  
  @override
  Future<List<Habit>> getAllHabits() async {
    try {
      final box = await _databaseService.getBox<Habit>('habits');
      return box.values.toList();
    } catch (e) {
      _logger.error('获取习惯失败', e);
      throw DatabaseException('获取习惯失败');
    }
  }
}
```

### 3.5 错误处理规范

- 使用统一的异常类层次结构
- 所有异常必须被捕获并处理
- 错误信息必须包含足够的上下文
- 在适当的层次处理不同类型的错误

```dart
// 异常捕获和处理
Future<void> doSomething() async {
  try {
    // 业务逻辑
  } on DatabaseException catch (e) {
    // 数据库错误处理
    logger.error('数据库错误', e);
    // 可能的恢复策略
  } on NetworkException catch (e) {
    // 网络错误处理
    logger.error('网络错误', e);
    // 可能的恢复策略
  } catch (e, stackTrace) {
    // 未知错误处理
    logger.error('未知错误', e, stackTrace);
    // 兜底处理
  }
}
```

### 3.6 依赖注入规范

- 所有依赖必须通过构造函数注入
- 避免使用全局服务定位器
- 按模块组织依赖注册
- 使用接口而非具体实现进行依赖注入

```dart
// 依赖注入示例
class HabitManagementPage extends StatelessWidget {
  final INavigationService _navigationService;
  final HabitProvider _habitProvider;
  
  const HabitManagementPage({
    Key? key,
    required INavigationService navigationService,
    required HabitProvider habitProvider,
  }) : _navigationService = navigationService,
       _habitProvider = habitProvider,
       super(key: key);
}
```

## 4. 模块开发指南

### 4.1 习惯管理模块

#### 4.1.1 数据模型

- 使用`Habit`作为核心实体
- 所有数据字段必须有明确的类型
- 避免在实体中包含业务逻辑

#### 4.1.2 业务规则

- 习惯ID必须唯一
- 习惯名称不能为空
- 目标天数必须为正整数
- 颜色和图标必须有效

#### 4.1.3 状态管理

- 使用`HabitProvider`管理习惯列表状态
- 实现加载、成功、错误三种状态
- 支持分页加载（如有需要）

#### 4.1.4 UI设计

- 列表视图使用`ListView`或`GridView`
- 支持下拉刷新和上拉加载更多
- 编辑和添加页面使用表单验证
- 所有操作提供加载状态反馈

### 4.2 统计功能模块

#### 4.2.1 数据模型

- 使用统计数据DTO传递统计结果
- 支持周、月、年多种时间维度
- 包含完成率、趋势等关键指标

#### 4.2.2 缓存策略

- 实现统计数据缓存
- 缓存有效期为5分钟
- 支持强制刷新

#### 4.2.3 性能考虑

- 避免频繁重新计算统计数据
- 对大型数据集使用惰性计算
- 考虑使用Worker进行复杂计算

### 4.3 专注功能模块

#### 4.3.1 状态管理

- 使用Stream管理实时状态变化
- 正确处理生命周期（前台/后台）
- 确保时钟准确性

#### 4.3.2 后台处理

- 使用`BackgroundTimerService`处理后台计时
- 正确处理应用被杀死的情况
- 支持通知提醒

#### 4.3.3 用户体验

- 提供暂停/恢复/停止功能
- 显示剩余时间和进度
- 支持不同的专注模式

## 5. UI组件开发规范

### 5.1 组件层次结构

- 基础组件（BaseButton, AppCard等）
- 业务组件（HabitCard, StatisticsChart等）
- 页面组件（HabitManagementPage等）

### 5.2 组件设计原则

- 单一职责：每个组件只负责一个功能
- 可重用性：设计时考虑复用场景
- 可测试性：组件应易于单元测试
- 性能优化：避免不必要的重建

### 5.3 通用组件使用

```dart
// 使用通用按钮组件
PrimaryButton(
  text: '保存',
  onPressed: _onSave,
  isLoading: isLoading,
  isDisabled: !isFormValid,
);

// 使用通用卡片组件
AppCard(
  padding: EdgeInsets.all(16),
  onTap: () => _onHabitTap(habit),
  child: Column(
    children: [
      Text(habit.name),
      // 其他内容
    ],
  ),
);
```

### 5.4 导航规范

- 使用`INavigationService`进行页面导航
- 避免直接使用Navigator
- 定义统一的路由常量
- 正确处理导航参数

```dart
// 导航服务使用示例
void _navigateToHabitDetail(Habit habit) {
  _navigationService.push(
    AppRoutes.habitDetail,
    arguments: {'habitId': habit.id},
  );
}
```

## 6. 测试规范

### 6.1 测试覆盖要求

- 核心业务逻辑：100%
- 关键UI组件：>80%
- 数据持久化：>90%
- 工具类：>95%

### 6.2 测试类型

- 单元测试：测试单个类或函数
- 集成测试：测试多个组件协作
- UI测试：测试用户界面交互

### 6.3 测试编写规范

- 使用mockito模拟依赖
- 测试各种边界条件
- 测试错误处理逻辑
- 测试异步操作

```dart
// 单元测试示例
void main() {
  late HabitProvider habitProvider;
  late MockGetHabitsUseCase mockGetHabitsUseCase;
  
  setUp(() {
    mockGetHabitsUseCase = MockGetHabitsUseCase();
    habitProvider = HabitProvider(mockGetHabitsUseCase);
  });
  
  test('loadHabits should update state correctly', () async {
    // Arrange
    final mockHabits = [Habit(id: '1', name: 'Test')];
    when(mockGetHabitsUseCase.execute()).thenAnswer((_) async => mockHabits);
    
    // Act
    await habitProvider.loadHabits();
    
    // Assert
    expect(habitProvider.isLoading, false);
    expect(habitProvider.habits, mockHabits);
    expect(habitProvider.error, null);
  });
}
```

## 7. 性能优化指南

### 7.1 内存管理

- 避免内存泄漏
- 正确使用StreamSubscription
- 避免不必要的大对象创建
- 使用常量构造函数

### 7.2 渲染优化

- 使用const构造器
- 避免不必要的重建
- 正确使用key
- 使用ListView.builder而非ListView

### 7.3 网络和存储优化

- 实现请求缓存
- 批量处理数据库操作
- 压缩数据传输
- 避免频繁的IO操作

## 8. 代码审查规范

### 8.1 审查重点

- 架构一致性
- 代码质量
- 错误处理
- 性能考虑
- 安全性

### 8.2 审查流程

1. 作者自检：使用lint工具检查
2. 团队审查：至少一名团队成员审查
3. 架构师审查：关键功能需架构师审查
4. 合并：通过审查后合并代码

### 8.3 审查清单

- [ ] 遵循架构设计
- [ ] 符合命名规范
- [ ] 错误处理完善
- [ ] 有适当的注释
- [ ] 通过测试
- [ ] 性能考虑充分
- [ ] 安全性考虑充分

## 9. 文档规范

### 9.1 代码注释

- 类和方法必须有文档注释
- 复杂逻辑必须有内联注释
- 避免冗余注释
- 使用dartdoc格式

```dart
/// 习惯提供器，负责管理习惯相关的状态
class HabitProvider extends ChangeNotifier {
  /// 加载所有习惯
  /// 
  /// 更新状态为加载中，然后调用用例获取数据，
  /// 最后根据结果更新状态并通知UI。
  Future<void> loadHabits() async {
    // 实现...
  }
}
```

### 9.2 技术文档

- 架构设计文档
- API文档
- 开发指南
- 部署文档

## 10. 安全规范

### 10.1 数据安全

- 敏感数据加密存储
- 避免明文存储密码
- 使用安全的存储方案

### 10.2 输入验证

- 所有用户输入必须验证
- 防止注入攻击
- 验证数据范围

### 10.3 权限管理

- 最小权限原则
- 正确处理权限请求
- 提供权限说明

## 11. 总结

本技术规范指南为Contrail项目提供了全面的开发规范，涵盖了架构设计、编码规范、模块开发、UI组件、测试、性能优化、代码审查、文档和安全等方面。所有团队成员必须严格遵守这些规范，确保项目代码的质量、可维护性和可扩展性。

规范将根据项目发展和技术演进定期更新，团队成员应关注最新版本的规范。