# 模块化设计改进方案

基于当前代码库结构，按照模块化设计思路，提出以下改进方案：

## 一、整体架构优化

### 1. 采用功能模块化结构
将现有按组件类型划分的结构重构为按业务功能划分的模块化结构：

```
lib/
├── app/              # 应用入口和核心配置
├── features/         # 功能模块
│   ├── habit/        # 习惯管理模块
│   ├── statistics/   # 统计分析模块
│   ├── profile/      # 用户配置模块
│   └── focus/        # 专注模式模块
├── shared/           # 共享组件和工具
│   ├── models/       # 共享数据模型
│   ├── widgets/      # 共享UI组件
│   ├── utils/        # 工具类
│   └── services/     # 共享服务
└── core/             # 核心框架
    ├── di/           # 依赖注入
    ├── routing/      # 路由管理
    └── state/        # 全局状态管理
```

### 2. 引入分层架构
为每个功能模块实现清晰的分层：
- 表示层（UI）
- 领域层（业务逻辑）
- 数据层（数据访问）

## 二、具体模块优化

### 1. 数据层模块化
- 创建`repository`层封装数据访问逻辑
- 为每个实体创建独立的repository接口和实现
- 使用依赖注入管理repository实例

```dart
// lib/features/habit/data/repositories/habit_repository.dart
abstract class HabitRepository {
  Future<List<Habit>> getHabits();
  Future<Habit> getHabitById(String id);
  Future<void> addHabit(Habit habit);
  Future<void> updateHabit(Habit habit);
  Future<void> deleteHabit(String id);
}

// Hive实现
class HiveHabitRepository implements HabitRepository {
  final Box<Habit> _habitBox;

  HiveHabitRepository(this._habitBox);

  @override
  Future<List<Habit>> getHabits() async {
    return _habitBox.values.toList();
  }

  // 其他方法实现...
}
```

### 2. 业务逻辑模块化
- 将业务逻辑从UI组件中分离出来
- 创建`use_case`或`interactor`层处理业务逻辑
- 确保业务逻辑与UI实现解耦

```dart
// lib/features/habit/domain/use_cases/get_habits_use_case.dart
class GetHabitsUseCase {
  final HabitRepository _habitRepository;

  GetHabitsUseCase(this._habitRepository);

  Future<List<Habit>> execute() async {
    try {
      final habits = await _habitRepository.getHabits();
      // 可以添加业务逻辑，如排序、过滤等
      return habits;
    } catch (e) {
      logger.error('获取习惯列表失败', e);
      rethrow;
    }
  }
}
```

### 3. UI层模块化
- 采用组件化设计，提高UI复用性
- 为每个功能模块创建独立的页面和组件
- 确保页面组件只负责展示数据和处理用户交互

### 4. 路由模块化
- 实现路由模块化，每个功能模块负责自己的路由配置
- 使用路由守卫实现访问控制
- 采用懒加载路由提高应用启动性能

```dart
// lib/core/routing/app_router.dart
class AppRouter {
  static final router = GoRouter(
    routes: [
      GoRoute(
        path: '/',
        builder: (context, state) => const MainTabPage(),
        routes: [
          ...HabitRoutes.routes,
          ...StatisticsRoutes.routes,
          ...ProfileRoutes.routes,
        ],
      ),
    ],
  );
}

// lib/features/habit/presentation/routes/habit_routes.dart
class HabitRoutes {
  static List<GoRoute> get routes => [
        GoRoute(
          path: 'habits',
          builder: (context, state) => const HabitManagementPage(),
        ),
        GoRoute(
          path: 'habits/add',
          builder: (context, state) => const AddHabitPage(),
        ),
        // 其他路由...
      ];
}
```

### 5. 依赖注入模块化
- 实现模块化的依赖注入配置
- 为每个功能模块创建独立的依赖模块
- 使用工厂模式或懒加载创建依赖实例

```dart
// lib/core/di/injection_container.dart
final sl = GetIt.instance;

Future<void> init() async {
  // 核心服务
  sl.registerLazySingleton(() => logger);

  // 数据层
  await _initDataLayer();

  // 领域层
  _initDomainLayer();

  // 表示层
  _initPresentationLayer();
}

void _initDomainLayer() {
  // Habit模块用例
  sl.registerFactory(() => GetHabitsUseCase(sl()));
  sl.registerFactory(() => AddHabitUseCase(sl()));
  sl.registerFactory(() => UpdateHabitUseCase(sl()));
  sl.registerFactory(() => DeleteHabitUseCase(sl()));

  // 其他模块用例...
}
```

## 三、实施建议

1. **逐步重构**：采用增量式重构策略，避免一次性大规模修改带来的风险

2. **先抽象后实现**：先定义接口和抽象类，再实现具体功能

3. **保持向后兼容**：确保重构过程中不破坏现有功能

4. **编写测试**：为关键组件编写单元测试和集成测试，确保重构质量

5. **文档更新**：及时更新架构文档，确保团队成员理解新的模块化结构

通过以上改进，代码库将更加模块化、可维护和可扩展，同时提高开发效率和代码质量。


## 进度追踪
### 后续工作建议
1. 1.
   完成剩余用例的实现(AddHabitUseCase, UpdateHabitUseCase, DeleteHabitUseCase等)
2. 2.
   重构其他页面和组件使用新的架构
3. 3.
   实现路由模块化
4. 4.
   编写单元测试和集成测试
5. 5.
   完善错误处理和边界情况处理